#!/usr/bin/env python2

"""
This module is a reimpementation of the ancient cgvg perl scripts.

Visit https://github.com/vrothberg/vgrep for more information.
"""

# (c) 2015 Valentin Rothberg <valentinrothberg@gmail.com>
#
# Licensed under the terms of the GNU GPL License version 3

import argparse
import os
import sys
import pickle
import re
import signal

from array import array
from pipes import quote
from subprocess import Popen, PIPE, STDOUT

HOMEDIR = os.getenv("HOME")
CACHE = HOMEDIR + "/.cache/vgrep"
EDITOR = os.getenv("EDITOR", "vim")

ANSI_REG = re.compile(r'\x1B\[[0-9;]*[ABCDEFGHJKSTfmnsulh]')


def parse_options():
    """
    User interface of this module.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--show', dest='show', action='store',
                        default="",
                        help="show indexed location in the system's editor")
    parser.add_argument('--no-git', dest='nogit', action='store_true',
                        default=False,
                        help="use 'grep' instead of 'git grep'")
    parser.add_argument('--no-git-submodules', dest='nogitsubmodules',
                        action='store_true', default=False,
                        help="do not search in git submodules")
    parser.add_argument('--no-less', dest='noless', action='store_true',
                        default=False,
                        help="print to stdout instead of using less")
    parser.add_argument('--no-header', dest='noheader', action='store_true',
                        default=False,
                        help="do not print the pretty header at the top of "
                             "the results")
    args, gitargs = parser.parse_known_args()
    return args, gitargs


def parse_line(sloc):
    """
    Returns indices of first and second delimiter of the input line.
    Delimiters are `\0', `:', `-'.

    One or both indices can be -1.
    """

    lfile = sloc.find('\0')
    if lfile == -1:
        lfile = sloc.find(':')
    lline = sloc.find('\0', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find(':', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find('-', lfile+1)

    return lfile, lline


def main():
    """
    Main routine of this module.
    """
    args, gitargs = parse_options()

    if args.show:
        slocs = load()
        cwd = rem_ansi(slocs.pop(0))
        if cwd != os.getcwd():
            sys.exit("Change directory to %s to show locations" % cwd)

        if slocs is None:
            sys.exit("Please grep for a symbol first")

        index = None
        try:
            index = int(args.show)
            sloc = rem_ansi(slocs[index])
        except (ValueError, IndexError):
            sys.exit("Please specify a valid index")

        lfile, lline = parse_line(sloc)
        if lfile == -1 or lline == -1:
            sys.exit("Please specify a valid index")
        cmd = "%s +%s %s" % (EDITOR, sloc[lfile+1:lline], sloc[:lfile])
        pop = Popen(cmd, shell=True)
        pop.wait()
        sys.exit(0)

    if gitargs:
        gitargs = ["'%s'" % x for x in gitargs]  # needed to pass args to grep
        grep_args = " ".join(gitargs)

        slocs = grep(grep_args, args.nogit, args.nogitsubmodules)
        slocs = filter(None, slocs)  # filter empty hits
        if not slocs:
            # dump and exit if there is not hit
            dump(slocs)
            sys.exit(0)

        # test ouput format of grep
        test = rem_ansi(slocs[0])
        if not re.match(r"^[^:\0]+[:\0]\d+[\0:-].*$", test):
            sys.stderr.write("Wrong format from (git) grep: '%s'\n" % test)
            sys.stderr.write("vgrep expects the format '%s:%s:%s' or '%s\\0%s\\0%s'\n"
                             % (blu('file'), green('line'), 'content',
                                blu('file'), green('line'), 'content'))

            sys.exit(1)

        dump(slocs)

    else:
        slocs = load()
        if not slocs:
            sys.exit("Could not load cached data")
        cwd = slocs.pop(0)
        if cwd != os.getcwd():
            sys.exit("Change directory to %s to show locations" % cwd)

    try:
        print_slocs(slocs, args.noless, args.noheader)
    except:
        pass


def yel(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[93m%s\033[0m" % string
    return "\033[33m%s\033[0m" % string


def green(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[92m%s\033[0m" % string
    return "\033[32m%s\033[0m" % string


def blu(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[94m%s\033[0m" % string
    return "\033[34m%s\033[0m" % string


def und(string):
    """
    Underline %string.
    """
    return "\033[4m%s\033[0m" % string


def rem_ansi(string):
    """
    Remove ANSI codes from string.
    """
    return ANSI_REG.sub('', string)


def print_slocs(slocs, noless, noheader):
    """
    Print SLOCS on terminal.
    """
    max_indx = len(str(len(slocs)))
    max_file = 0
    max_line = 0

    lengths = array('i', [])

    pl = parse_line  # makes it faster by avoiding function lookups
    for sloc in slocs:
        sloc = rem_ansi(sloc)
        lfile, lline = pl(sloc)

        lengths.append(lfile)
        lengths.append(lline)
        if lfile > max_file:
            max_file = lfile
        if (lline-lfile) > max_line:
            max_line = (lline-lfile)

    fdc = sys.stdout
    pop = None
    if noless is False:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        pop = Popen("less -FRXS", shell=True, stdin=PIPE)
        fdc = pop.stdin

    if noheader is False:
        if len("Index") > max_indx:
            max_indx = len("Index")
        if len("File") > max_file:
            max_file = len("File")
        if len("Line") > max_line:
            max_line = len("Line")

        fdc.write(und(yel('{0:>{1}}'.format("Index", max_indx))) + " ")
        fdc.write(und(blu('{0:<{1}}'.format("File", max_file))) + " ")
        fdc.write(und(green('{0:>{1}}'.format("Line", max_line))) + " ")
        fdc.write(und("Content") + "\n")

    lfile, lline, lcount = 0, 0, 0
    for i in range(0, len(slocs)):
        sloc = rem_ansi(slocs[i])
        lfile = lengths[i*2] + 1
        lline = lengths[i*2 + 1] + 1

        if lfile == 0 or lline == 0:
            fdc.write(yel("-" * (max_indx+max_file+max_line+2)) + " " + sloc + "\n")
            continue

        light = lcount % 2
        lcount += 1

        fdc.write(yel('{0:>{1}} '.format(i, max_indx), light))
        fdc.write(blu('{0:<{1}} '.format(sloc[:lfile-1].lstrip('./'), max_file), light))
        fdc.write(green('{0:>{1}} '.format(sloc[lfile:lline-1], max_line), light))
        fdc.write(slocs[i][lline:].lstrip() + "\n")

    fdc.close()
    if noless is False:
        pop.wait()


def execute(cmd):
    """
    Execute %cmd and return stdout.  Exit in case of error.
    """
    pop = Popen(cmd, stdout=PIPE, stderr=STDOUT, shell=True)
    (stdout, _) = pop.communicate()  # wait until finished
    if pop.returncode != 0:
        if stdout != '':
            sys.exit("Command failed: %s\n%s" % (cmd, stdout))
    return stdout


def grep(grep_args, nogit, nogitsubmodules):
    """
    Search symbol in current Git tree and return the output. If %nogit is set
    grep is called instead of git grep.
    """
    grep_args = "-In --color=always %s" % grep_args

    if nogit is True:
        # overwrite grep colors to only highlight matches
        colors = "GREP_COLORS='ms=01;31:mc=:sl=:cx=:fn=:ln=:bn=:se='"
        grep_args += " -r"
        return execute("%s grep -Z %s ." % (colors, grep_args)).rsplit("\n")

    colors = "-c 'color.grep.match=red bold'"
    git_grep_cmd = "HOME= git %s grep -z %s" % (colors, grep_args)
    git_grep_results = execute(git_grep_cmd).rsplit("\n")

    # When submodules are ignored, we can return here.
    if nogitsubmodules is True:
        return git_grep_results

    cwd = os.path.abspath(os.path.curdir)
    # Get all submodules (recursive)
    list_cmd = "git submodule --quiet foreach --recursive %s" % \
               quote('echo "$toplevel/$path"')
    submodules = execute(list_cmd).rsplit("\n")
    for submodule in filter(None, submodules):
        # check if submodule is below the current working directory
        submodule = os.path.normpath(submodule)
        if os.path.commonprefix([submodule, cwd]) != cwd:
            continue
        # Get the path relative to the CWD
        submodule = os.path.relpath(submodule, cwd)

        # Start grep within the submodule
        sub_grep_cmd = "cd %s && %s" % (quote(submodule), git_grep_cmd)
        lines = execute(sub_grep_cmd).rsplit("\n")
        # Prepend the relative submodule path to each line
        for line in filter(None, lines):
            git_grep_results.append(os.path.join(submodule, line))

    return git_grep_results

old_child = None
def dump(data):
    """
    Fork and dump %data to the local cache.
    """
    global old_child
    if old_child:
        os.kill(old_child, 15)
        os.waitpid(old_child, 0)

    child = os.fork()
    if child:
        old_child = child
        return

    # child process
    cwd = os.getcwd()
    data.insert(0, cwd)
    if not os.path.exists(os.path.dirname(CACHE)):
        os.makedirs(os.path.dirname(CACHE))
    # Remove old cache
    if os.path.exists(CACHE):
        os.unlink(CACHE)
    pickle.dump(data, open(CACHE, "wb"))
    sys.exit(0)


def load():
    """
    Load and return data from the local cache.
    """
    try:
        return pickle.load(open(CACHE, "rb"))
    except:
        return None


if __name__ == "__main__":
    main()
