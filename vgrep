#!/usr/bin/env python2

"""
This module is a reimpementation of the ancient cgvg perl scripts.

Visit https://github.com/vrothberg/vgrep for more information.
"""

# (c) 2015 Valentin Rothberg <valentinrothberg@gmail.com>
#
# Licensed under the terms of the GNU GPL License version 3

import argparse
import os
import sys
import pickle
import re
import signal

from array import array
from pipes import quote
from subprocess import Popen, PIPE, STDOUT
try:
    import readline
except:
    pass


HOMEDIR = os.getenv("HOME")
CACHE = HOMEDIR + "/.cache/vgrep"
EDITOR = os.getenv("EDITOR", "vim")

ANSI_REG = re.compile(r'\x1B\[[0-9;]*[ABCDEFGHJKSTfmnsulh]')


def parse_options():
    """
    User interface of this module.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--show', dest='show', action='store',
                        default=False, nargs='?',
                        help="show indexed location in the system's editor")
    parser.add_argument('--no-git', dest='nogit', action='store_true',
                        default=False,
                        help="use 'grep' instead of 'git grep'")
    parser.add_argument('--no-git-submodules', dest='nogitsubmodules',
                        action='store_true', default=False,
                        help="do not search in git submodules")
    parser.add_argument('--no-less', dest='noless', action='store_true',
                        default=False,
                        help="print to stdout instead of using less")
    parser.add_argument('--no-header', dest='noheader', action='store_true',
                        default=False,
                        help="do not print the pretty header at the top of "
                             "the results")
    args, gitargs = parser.parse_known_args()
    return args, gitargs


def parse_line(sloc):
    """
    Returns indices of first and second delimiter of the input line.
    Delimiters are `\0', `:', `-'.

    One or both indices can be -1.
    """

    lfile = sloc.find('\0')
    if lfile == -1:
        lfile = sloc.find(':')
    lline = sloc.find('\0', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find(':', lfile+1)
    if lline == -1 or not sloc[lfile+1:lline].isdigit():
        lline = sloc.find('-', lfile+1)

    return lfile, lline


def main():
    """
    Main routine of this module.
    """
    args, gitargs = parse_options()


    if gitargs:
        gitargs = ["'%s'" % x for x in gitargs]  # needed to pass args to grep
        grep_args = " ".join(gitargs)

        slocs = grep(grep_args, args.nogit, args.nogitsubmodules)
        slocs = filter(None, slocs)  # filter empty hits
        if not slocs:
            # dump and exit if there is not hit
            dump(slocs)
            sys.exit(0)

        # test ouput format of grep
        test = rem_ansi(slocs[0])
        if not re.match(r"^[^:\0]+[:\0]\d+[\0:-].*$", test):
            sys.stderr.write("Wrong format from (git) grep: '%s'\n" % test)
            sys.stderr.write("vgrep expects the format '%s:%s:%s' or '%s\\0%s\\0%s'\n"
                             % (blu('file'), green('line'), 'content',
                                blu('file'), green('line'), 'content'))

            sys.exit(1)

        dump(slocs)

    else:
        slocs = load()
        if not slocs:
            sys.exit("Could not load cached data")
        cwd = rem_ansi(slocs.pop(0))
        if cwd != os.getcwd():
            sys.exit("Change directory to %s to show locations" % cwd)
        if slocs is None:
            sys.exit("Please grep for a symbol first")

    if (gitargs and args.show is None) or args.show is False:
        try:
            print_slocs(slocs, args.noless, args.noheader)
        except IOError:
            pass

    ret = None
    # -s given but no show string given
    if args.show is None:
        show_help = True
        while True:
            try:
                show_expr = ask_show_expr(show_help)
            except EOFError:
                break
            show_help = False
            dispatch_show_cmd(show_expr, slocs, args)
    elif args.show:
        ret = dispatch_show_cmd(args.show, slocs, args)

    if ret == error:
        sys.exit(-1)


def ask_show_expr(verbose=False):
    if verbose:
        print "help: <Selector><Cmd>"
        print "      Selector: ",\
            blu("`3'"), "(one)",\
            blu("`5,23'"),"(mult.)",\
            blu("`7-10'"), "(range)",\
            blu("`/ker.el/'"), "(regex)"
        print "      Cmd: ",\
            blu("p")+"rint,",\
            blu("s")+"how,",\
            blu("c")+"ontext,",\
            blu("f")+"iles,",\
            "e" + blu("x")+"ecute,",\
            blu("q")+"uit,"
        print '      E.g.: 40,45s -- show matches 40 and 45 in $EDITOR'

    return raw_input(green("What do you want to see?> "))

def dispatch_show_cmd(show_expr, slocs, options):
    try:
        indices, cmd, cmd_arg = parse_show(show_expr, slocs)
    except (ValueError, IndexError, AssertionError) as e:
        return error("parse error: " + str(e))

    options.show_cmds = {
        's': show_cmd_open,
        'p': show_cmd_print,
        'P': show_cmd_print_and_save,
    }
    if not cmd in options.show_cmds:
        return error("Command not implemented: %s" % cmd)
    return options.show_cmds[cmd](slocs, indices, cmd_arg, options)


################################################################
# Utility Functions
################################################################

def yel(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[93m%s\033[0m" % string
    return "\033[33m%s\033[0m" % string


def green(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[92m%s\033[0m" % string
    return "\033[32m%s\033[0m" % string


def blu(string, light=0):
    """
    Color %string.
    """
    if light:
        return "\033[94m%s\033[0m" % string
    return "\033[34m%s\033[0m" % string


def und(string):
    """
    Underline %string.
    """
    return "\033[4m%s\033[0m" % string

def warning(msg):
    """Prints a warning to the terminal"""
    print yel("Warning:", True), msg
    return warning

def error(msg):
    """Prints an error message"""
    print msg
    return error

def rem_ansi(string):
    """
    Remove ANSI codes from string.
    """
    return ANSI_REG.sub('', string)

################################################################
# Parse Input Functions
################################################################

def parse_show(show, slocs):
    m = re.match("^([0-9, :-]*|/[^/]*/)([hqspPfcx].*)?$", show)
    assert m, "invalid show expression: " + show
    if m.groups()[1] is None:
        cmd = 's'
        args = ''
    elif m.group(2):
        cmd = m.group(2)[0]
        args = m.group(2)[1:]
    else:
        assert not m.group(3), "invalid show expression: " + show

    indices = []
    # If range is '', select all
    if not m.group(1):
        return range(0, len(slocs)), cmd, args
    # Parse regex
    if m.group(1).startswith("/"):
        regex = re.compile(m.group(1)[1:-1])
        for idx, line in enumerate(slocs):
            if re.search(regex, line):
                indices.append(idx)
        return indices, cmd, args

    # parse literal range expressions
    for subrange in filter(None, re.split("[ ,]", m.group(1))):
        if '-' in subrange or ':' in subrange:
            if ':' in subrange:
                start, end = subrange.split(':', 1)
            else:
                start, end = subrange.split('-', 1)
            if not start:
                start = "0"
            if not end:
                end = str(len(slocs)-1)
            indices.extend(range(int(start), int(end) + 1))
        else:
            indices.append(int(subrange))
    assert all([x < len(slocs) for x in indices]), "range item too large"
    return indices, cmd, args

################################################################
# Show Commands
################################################################

def show_cmd_open(slocs, indices, cmd_arg, option):
    """Opens $EDITOR for every match.

       This command does open the program, given by the $EDITOR
       environment variable, for every selected match at the given line.

    """
    if len(indices) > 3:
        x = raw_input("Matched %s lines, really visited them all? (N/y)" % len(indices))
        if not ("y" in x or 'Y' in x):
            return
    for idx in indices:
        sloc = rem_ansi(slocs[idx])
        lfile, lline = parse_line(sloc)
        if lfile == -1 or lline == -1:
            return error("Please specify a valid index")
        cmd = "%s +%s %s" % (EDITOR, sloc[lfile+1:lline], sloc[:lfile])
        pop = Popen(cmd, shell=True)
        pop.wait()


def show_cmd_print(slocs, indices, cmd_arg, options):
    """Prints all matched lines"""
    try:
        print_slocs(slocs, options.noless, options.noheader, set(indices))
    except IOError as e:
        return error("print command failed: " + e)


def show_cmd_print_and_save(slocs, indices, cmd_arg, options):
    """Replaces the match cache by the given selection. The selected
       matches are renumbered and the new match cache is printed.""" 
    match_slocs = []
    for idx in indices:
        match_slocs.append(slocs[idx])
    # Save matched results
    dump(match_slocs)
    # Update the slocs variable
    slocs[:] = match_slocs
    # Output the matched lines (reordered)
    try:
        print_slocs(match_slocs, options.noless, options.noheader)
    except IOError as e:
        return error("print and save command failed: " + e)


################################################################
# Backend Input/Output Functions
################################################################

def print_slocs(slocs, noless, noheader, indices=None):
    """
    Print SLOCS on terminal.
    """
    max_indx = len(str(len(slocs)))
    max_file = 0
    max_line = 0

    lengths = array('i', [])

    pl = parse_line  # makes it faster by avoiding function lookups
    for i in range(0, len(slocs)):
        if indices is not None and not i in indices:
            lengths.append(-1)
            lengths.append(-1)
            continue
        sloc = rem_ansi(slocs[i])
        lfile, lline = pl(sloc)
        lengths.append(lfile)
        lengths.append(lline)
        if lfile > max_file:
            max_file = lfile
        if (lline-lfile) > max_line:
            max_line = (lline-lfile)

    fdc = sys.stdout
    pop = None
    if noless is False:
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        pop = Popen("less -FRXS", shell=True, stdin=PIPE)
        fdc = pop.stdin

    if noheader is False:
        if len("Index") > max_indx:
            max_indx = len("Index")
        if len("File") > max_file:
            max_file = len("File")
        if len("Line") > max_line:
            max_line = len("Line")

        fdc.write(und(yel('{0:>{1}}'.format("Index", max_indx))) + " ")
        fdc.write(und(blu('{0:<{1}}'.format("File", max_file))) + " ")
        fdc.write(und(green('{0:>{1}}'.format("Line", max_line))) + " ")
        fdc.write(und("Content") + "\n")

    lfile, lline, lcount = 0, 0, 0
    for i in range(0, len(slocs)):
        # If we have an index set, print only those
        if indices is not None and (not i in indices):
            continue

        sloc = rem_ansi(slocs[i])
        lfile = lengths[i*2] + 1
        lline = lengths[i*2 + 1] + 1

        if lfile == 0 or lline == 0:
            fdc.write(yel("-" * (max_indx+max_file+max_line+2)) + " " + sloc + "\n")
            continue

        light = lcount % 2
        lcount += 1

        fdc.write(yel('{0:>{1}} '.format(i, max_indx), light))
        fn = sloc[:lfile-1]
        if fn.startswith("./"):
            fn = fn[2:]
        fdc.write(blu('{0:<{1}} '.format(fn, max_file), light))
        fdc.write(green('{0:>{1}} '.format(sloc[lfile:lline-1], max_line), light))
        fdc.write(slocs[i][lline:].lstrip() + "\n")

    fdc.close()
    if noless is False:
        pop.wait()


def execute(cmd):
    """
    Execute %cmd and return stdout.  Exit in case of error.
    """
    pop = Popen(cmd, stdout=PIPE, stderr=STDOUT, shell=True)
    (stdout, _) = pop.communicate()  # wait until finished
    if pop.returncode != 0:
        if stdout != '':
            sys.exit("Command failed: %s\n%s" % (cmd, stdout))
    return stdout


def grep(grep_args, nogit, nogitsubmodules):
    """
    Search symbol in current Git tree and return the output. If %nogit is set
    grep is called instead of git grep.
    """
    grep_args = "-In --color=always %s" % grep_args

    if nogit is True:
        # overwrite grep colors to only highlight matches
        colors = "GREP_COLORS='ms=01;31:mc=:sl=:cx=:fn=:ln=:bn=:se='"
        grep_args += " -r"
        return execute("%s grep -Z %s ." % (colors, grep_args)).rsplit("\n")

    colors = "-c 'color.grep.match=red bold'"
    git_grep_cmd = "HOME= git %s grep -z %s" % (colors, grep_args)
    git_grep_results = execute(git_grep_cmd).rsplit("\n")

    # When submodules are ignored, we can return here.
    if nogitsubmodules is True:
        return git_grep_results

    cwd = os.path.abspath(os.path.curdir)
    # Get all submodules (recursive)
    list_cmd = "git submodule --quiet foreach --recursive %s" % \
               quote('echo "$toplevel/$path"')
    submodules = execute(list_cmd).rsplit("\n")
    for submodule in filter(None, submodules):
        # check if submodule is below the current working directory
        submodule = os.path.normpath(submodule)
        if os.path.commonprefix([submodule, cwd]) != cwd:
            continue
        # Get the path relative to the CWD
        submodule = os.path.relpath(submodule, cwd)

        # Start grep within the submodule
        sub_grep_cmd = "cd %s && %s" % (quote(submodule), git_grep_cmd)
        lines = execute(sub_grep_cmd).rsplit("\n")
        # Prepend the relative submodule path to each line
        for line in filter(None, lines):
            git_grep_results.append(os.path.join(submodule, line))

    return git_grep_results

old_child = None
def dump(data):
    """
    Fork and dump %data to the local cache.
    """
    global old_child
    if old_child:
        os.kill(old_child, 15)
        os.waitpid(old_child, 0)

    child = os.fork()
    if child:
        old_child = child
        return

    # child process
    cwd = os.getcwd()
    data.insert(0, cwd)
    if not os.path.exists(os.path.dirname(CACHE)):
        os.makedirs(os.path.dirname(CACHE))
    # Remove old cache
    if os.path.exists(CACHE):
        os.unlink(CACHE)
    pickle.dump(data, open(CACHE, "wb"))
    sys.exit(0)


def load():
    """
    Load and return data from the local cache.
    """
    try:
        return pickle.load(open(CACHE, "rb"))
    except:
        return None


if __name__ == "__main__":
    main()
